---
description: "TAGS: [global,memory,context,preservation,complex,algorithm] | TRIGGERS: complex,feature,algorithm,state-machine,api-integration,large-file,intensive,collaborative,refined | SCOPE: global | DESCRIPTION: Context preservation system for technically complex features requiring intensive collaborative development"
alwaysApply: false
---
# Master Rule: Complex Feature Context Preservation

## Section 1: Critical Feature Detection

### 1.1 Technical Complexity Signals
**[STRICT]** You **MUST** activate this protocol if you detect:
- Functions >100 lines or complex conditional logic (>5 nested levels)
- Custom algorithms, calculations, or state machines
- Integration with external APIs or complex data transformations
- Files >500 lines serving multiple responsibilities
- Complex business logic with multiple edge cases
- Features with intricate user interaction flows

### 1.2 Collaborative Development Indicators
**[STRICT]** Automatically activate for code that shows signs of:
- Multiple iterations and refinements (complex comment patterns)
- Sophisticated error handling and edge case management
- Advanced architectural patterns (factory, strategy, observer)
- Integration points between multiple systems
- Performance optimizations and caching mechanisms

### 1.3 Universal Pattern Recognition
**[GUIDELINE]** Learn to recognize these patterns across any codebase:
- Code with extensive validation and sanitization
- Features handling multiple data formats or protocols
- Components with complex lifecycle management
- Systems with intricate permission and access control
- Features with advanced user experience considerations

## Section 2: Creating Contextual Snapshots

### 2.1 Automatic Documentation
**[STRICT]** Before any modification of a critical feature, you **MUST**:

1. **Create a Mental Snapshot:**
   ```
   [CONTEXT SNAPSHOT - {DATE}]
   Feature: {feature name}
   Complexity indicators: {technical signals detected}
   Critical logic points: {key algorithms/calculations}
   Data flow: {input → processing → output}
   Interdependencies: {other affected components}
   Edge cases handled: {list of special cases}
   ```

2. **Identify Points of No Return:**
   - Which algorithms should NEVER be modified?
   - Which behaviors MUST be preserved exactly?
   - Which integration points are fragile?
   - Which performance optimizations are critical?

### 2.2 Cross-Validation Requirements
**[STRICT]** For complex features, you **MUST**:
- Read ALL related files before modifying
- Understand the complete data flow and transformations
- Identify all entry and exit points
- Map error handling and recovery mechanisms
- Understand performance implications and constraints

### 2.3 Context Preservation Documentation
**[STRICT]** Document critical context elements:
- **Business Logic:** Why certain decisions were made
- **Technical Constraints:** Performance, security, compatibility requirements
- **Edge Cases:** Unusual scenarios and their handling
- **Integration Points:** How feature connects to other systems
- **User Experience:** Critical UX flows and interactions

## Section 3: Defensive Modification Strategy

### 3.1 Maximum Preservation Principle
**[STRICT]** When modifying critical features:
- **Preserve** always more than necessary
- **Add** rather than replace existing logic
- **Comment** your modifications extensively for traceability
- **Maintain** existing code paths as fallbacks
- **Document** any assumptions or limitations

### 3.2 Incremental Enhancement Approach
**[STRICT]** For complex features, use this strategy:
1. **Understand** the complete existing implementation
2. **Extend** functionality without breaking existing paths
3. **Test** each incremental change thoroughly
4. **Validate** that all original behaviors are preserved
5. **Document** the enhancement rationale and approach

### 3.3 Rollback Strategy Preparation
**[STRICT]** Always prepare a rollback plan:
- Keep the "before modification" state clearly documented
- Prepare specific steps to revert if necessary
- Document all critical changes with reversal instructions
- Identify validation points to confirm successful rollback

## Section 4: Proactive Communication

### 4.1 Preventive Reporting
**[STRICT]** If you identify a critical feature, announce:
```
[COMPLEX FEATURE DETECTED]
I have identified that this feature shows signs of intensive development and refinement.
Technical complexity indicators:
- {list of complexity signals}
- {list of sophisticated patterns}

Before proceeding, may I confirm that the requested modification will not risk impacting:
- {list of critical algorithms/logic}
- {list of complex behaviors}
- {list of integration points}
```

### 4.2 Risk Assessment Communication
**[STRICT]** For risky modifications, use this formula:
> "This modification touches a technically complex feature with sophisticated logic. May I have your confirmation that I can proceed, and are there specific algorithms, behaviors, or integration points that I must absolutely preserve?"

### 4.3 Collaborative Validation Request
**[STRICT]** When uncertainty exists about feature criticality:
```
[COLLABORATIVE VALIDATION REQUEST]
I've detected complex patterns in this feature that suggest careful collaborative development.
Complexity indicators: {technical signals}
Risk factors: {potential impact points}

Could you confirm:
1. Which aspects of this feature are most critical to preserve?
2. Are there specific user scenarios or edge cases I should be aware of?
3. Are there performance or integration constraints I should consider?
```

## Section 5: Continuous Learning & Improvement

### 5.1 Pattern Recognition Enhancement
**[GUIDELINE]** Continuously improve ability to recognize:
- Code patterns that indicate sophisticated collaborative development
- Architectural decisions that reflect complex requirements
- Comments and documentation that signal important design choices
- Performance optimizations and their underlying rationale
- Security measures and their implementation patterns

### 5.2 Context Loss Prevention
**[GUIDELINE]** After each complex feature interaction:
- Analyze what context was most critical to preserve
- Identify early warning signals for feature complexity
- Refine detection heuristics based on outcomes
- Document lessons learned for future similar features

### 5.3 Collaborative Memory Building
**[GUIDELINE]** Build understanding of:
- How complex features evolve through collaborative refinement
- Common patterns in sophisticated business logic implementation
- Integration challenges and their typical solutions
- Performance optimization strategies and their trade-offs

## Section 6: Emergency Protocols

### 6.1 Complexity Overwhelm Response
**[STRICT]** If feature complexity exceeds understanding capacity:
```
[COMPLEXITY OVERWHELM]
This feature's complexity exceeds my current analysis capacity.
Complexity factors: {list overwhelming aspects}
Risk assessment: CRITICAL - Unable to guarantee preservation of all functionality

I recommend:
1. Human expert review before any modifications
2. Detailed documentation of current behavior
3. Comprehensive testing strategy development
```

### 6.2 Context Loss Recovery
**[STRICT]** If context loss is detected during modification:
- **Stop** all modification activities immediately
- **Document** what context was lost and when
- **Revert** to last known good state if possible
- **Request** guidance on context recovery approach

---

**Note:** This rule works in synergy with the Code Modification Safety Protocol to provide specialized protection for technically complex features that require intensive collaborative development.